<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>リアルタイムピアノ音楽生成</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.39/Tone.min.js"></script>
    <link rel="stylesheet" href="assets/styles.css">
</head>
<body>
    <h1>ピアノ音楽生成アプリ</h1>

    <div class="control-group">
        <h3>声部の管理</h3>
        <div id="voices-container">
            <!-- 声部のコントロールがここに動的に追加される -->
        </div>
        <div class="control-item">
            <button id="addVoice">声部を追加</button>
        </div>
    </div>

    <button id="playButton" disabled>音楽を再生</button>
    <button id="stopButton">停止</button>

    <script>
        class Voice {
            constructor(id) {
                this.id = id;
                this.melodyRow = [];
                this.baseRow = [];
                this.rowRetro = [];
                this.rowInverted = [];
                this.rowRetroInverted = [];
                this.sequenceIndex = 0;
                
                // 各声部のパラメータ
                this.params = {
                    velocity: 0.5,
                    velocityVariation: 75,
                    rangeLower: 60,
                    rangeUpper: 71,
                    tempo: 240,
                    duration: 50,
                    rest: true,
                    restProbability: 25,
                    chordProbability: 0,
                    melodicCoherence: 0
                };

                // スケジューリング用のプロパティをシンプルに
                this.nextNoteTime = null;  // 次の音を鳴らす時間
                this.schedulerTimer = null;
                this.isActive = false;
                this.noteQueue = []; // 音情報のキューを追加
                
                this.createControls();
            }

            createControls() {
                const container = document.createElement('div');
                container.className = 'voice-controls';
                container.id = `voice-${this.id}`;
                container.dataset.voiceId = this.id;
                container.innerHTML = `
                    <div class="voice-header">
                        <h4>声部 ${this.id + 1}</h4>
                        <button class="delete-voice" data-voice-id="${this.id}" type="button">×</button>
                    </div>
                    <div class="control-item">
                        <label>音量:</label>
                        <input type="range" class="voice-velocity" min="0" max="1" step="0.1" value="${this.params.velocity}">
                        <span class="voice-velocity-value">${this.params.velocity}</span>
                    </div>
                    <div class="control-item">
                        <label>音量のばらつき:</label>
                        <input type="range" class="voice-velocity-variation" min="0" max="100" step="5" value="${this.params.velocityVariation}">
                        <span class="voice-velocity-variation-value">${this.params.velocityVariation}%</span>
                    </div>
                    <div class="control-item">
                        <label>テンポ:</label>
                        <input type="range" class="voice-tempo" min="60" max="480" step="10" value="${this.params.tempo}">
                        <span class="voice-tempo-value">${this.params.tempo} BPM</span>
                    </div>
                    <div class="control-item">
                        <label>複雑度:</label>
                        <input type="range" class="voice-duration" min="0" max="100" step="5" value="${this.params.duration}">
                        <span class="voice-duration-value">${this.params.duration} (${getDurationDescription(this.params.duration)})</span>
                    </div>
                    <div class="control-item">
                        <label>音域:</label>
                        <select class="voice-range-lower">
                            ${this.generateNoteOptionsHtml(this.params.rangeLower)}
                        </select>
                        <span>から</span>
                        <select class="voice-range-upper">
                            ${this.generateNoteOptionsHtml(this.params.rangeUpper)}
                        </select>
                    </div>
                    <div class="control-item">
                        <label>休符を含める:</label>
                        <input type="checkbox" class="voice-rest" ${this.params.rest ? 'checked' : ''}>
                    </div>
                    <div class="control-item">
                        <label>休符の確率:</label>
                        <input type="range" class="voice-rest-probability" min="10" max="50" step="5" value="${this.params.restProbability}">
                        <span class="voice-rest-probability-value">${this.params.restProbability}%</span>
                    </div>
                    <div class="control-item">
                        <label>同時発音の確率:</label>
                        <input type="range" class="voice-chord-probability" min="0" max="100" step="5" value="${this.params.chordProbability}">
                        <span class="voice-chord-probability-value">${this.params.chordProbability}% (単音のみ)</span>
                    </div>
                `;

                document.getElementById('voices-container').appendChild(container);
                
                const deleteButton = container.querySelector('.delete-voice');
                deleteButton.addEventListener('click', () => {
                    removeVoice(parseInt(deleteButton.dataset.voiceId));
                });
                
                this.setupEventListeners(container);
            }

            scheduleNextNote() {
                if (!this.isActive) return;
                if (this.noteQueue.length === 0) {
                    setTimeout(() => this.scheduleNextNote(), 100);
                }

                const noteData = this.noteQueue.shift(); // キューから音情報を取得

                // 現在の音を再生
                noteData.notes.forEach(note => {
                    pianoSampler.triggerAttackRelease(
                        Tone.Frequency(note, "midi").toNote(),
                        noteData.duration,
                        this.nextNoteTime == null ? undefined : this.nextNoteTime,
                        noteData.velocity
                    );
                });

                // 次の音を鳴らす時間を計算
                const duration = getDurationInMilliseconds(noteData.duration, this.params.tempo);
                this.nextNoteTime = Tone.now() + (duration / 1000);

                // 次の音符を再帰的にスケジュール
                setTimeout(() => this.scheduleNextNote(), duration);
            }

            fetchNotesIfNeeded() {
                if (!this.isActive) return;
                const minQueueLength = 5; // キューに保持しておく最小の音情報数
                if (this.noteQueue.length < minQueueLength && ws && ws.readyState === WebSocket.OPEN) {
                    const notesToFetch = minQueueLength - this.noteQueue.length;
                    ws.send(JSON.stringify({
                        type: 'generate_notes',
                        voiceId: this.id,
                        params: this.params,
                        duration: notesToFetch
                    }));
                }
                // 次の音符を再帰的にスケジュール
                setTimeout(() => this.fetchNotesIfNeeded(), 100);
            }

            startPlaying() {
                this.isActive = true;
                this.nextNoteTime = null;
                this.fetchNotesIfNeeded(); // 再生開始時に音情報を取得
                this.scheduleNextNote(); // 最初の音を再生するために呼び出す
            }

            stopPlaying() {
                this.isActive = false;
                if (this.schedulerTimer) {
                    clearTimeout(this.schedulerTimer);
                    this.schedulerTimer = null;
                }
            }

            setupEventListeners(container) {
                // 各パラメータの変更を監視
                container.querySelector('.voice-velocity').addEventListener('input', (e) => {
                    this.params.velocity = parseFloat(e.target.value);
                    container.querySelector('.voice-velocity-value').textContent = e.target.value;
                });

                container.querySelector('.voice-tempo').addEventListener('input', (e) => {
                    this.params.tempo = parseInt(e.target.value);
                    container.querySelector('.voice-tempo-value').textContent = `${e.target.value} BPM`;
                });

                // 音域の変更を監視
                const rangeLower = container.querySelector('.voice-range-lower');
                const rangeUpper = container.querySelector('.voice-range-upper');
                
                rangeLower.addEventListener('change', () => {
                    this.params.rangeLower = parseInt(rangeLower.value);
                    if (this.params.rangeLower > this.params.rangeUpper) {
                        this.params.rangeLower = this.params.rangeUpper;
                        rangeLower.value = this.params.rangeUpper;
                    }
                });

                rangeUpper.addEventListener('change', () => {
                    this.params.rangeUpper = parseInt(rangeUpper.value);
                    if (this.params.rangeUpper < this.params.rangeLower) {
                        this.params.rangeUpper = this.params.rangeLower;
                        rangeUpper.value = this.params.rangeLower;
                    }
                });

                container.querySelector('.voice-velocity-variation').addEventListener('input', (e) => {
                    this.params.velocityVariation = parseInt(e.target.value);
                    container.querySelector('.voice-velocity-variation-value').textContent = `${e.target.value}%`;
                });

                container.querySelector('.voice-duration').addEventListener('input', (e) => {
                    this.params.duration = parseInt(e.target.value);
                    container.querySelector('.voice-duration-value').textContent = 
                        `${e.target.value} (${getDurationDescription(parseInt(e.target.value))})`;
                });

                container.querySelector('.voice-rest').addEventListener('change', (e) => {
                    this.params.rest = e.target.checked;
                });

                container.querySelector('.voice-rest-probability').addEventListener('input', (e) => {
                    this.params.restProbability = parseInt(e.target.value);
                    container.querySelector('.voice-rest-probability-value').textContent = `${e.target.value}%`;
                });

                container.querySelector('.voice-chord-probability').addEventListener('input', (e) => {
                    this.params.chordProbability = parseInt(e.target.value);
                    const description = this.getChordProbabilityDescription(e.target.value);
                    container.querySelector('.voice-chord-probability-value').textContent = `${e.target.value}% (${description})`;
                });
            }

            generateNextNote() {
                if (!this.melodyRow.length || this.sequenceIndex >= this.melodyRow.length) {
                    const lastNote = this.melodyRow.length ? this.melodyRow[this.melodyRow.length - 1] : null;
                    
                    if (!this.melodyRow.length || Math.random() < 0.25) {
                        this.baseRow = generateNewSequence();
                        this.rowRetro = retrograde(this.baseRow);
                        this.rowInverted = inversion(this.baseRow);
                        this.rowRetroInverted = retrograde(this.rowInverted);
                    }
                    
                    const selectedRow = [
                        this.baseRow, 
                        this.rowRetro, 
                        this.rowInverted, 
                        this.rowRetroInverted
                    ][Math.floor(Math.random() * 4)];
                    
                    this.melodyRow = selectedRow.map((note, index) => {
                        const previousNote = index > 0 ? this.melodyRow[index - 1] : lastNote;
                        return adjustNoteToRange(note, this.params.rangeLower, this.params.rangeUpper, 0, previousNote);
                    }).filter(note => note !== null);
                    
                    this.sequenceIndex = 0;
                }

                const chordProb = this.params.chordProbability;
                let numNotes = 1;
                
                if (chordProb > 0) {
                    const random = Math.random() * 100;
                    if (chordProb <= 50) {
                        const twoNoteProb = chordProb;
                        if (random < twoNoteProb) numNotes = 2;
                    } else {
                        const ratio = (chordProb - 50) / 50;
                        const threeNoteProb = ratio * 33;
                        const remainingProb = 100 - threeNoteProb;
                        const oneAndTwoNoteProb = remainingProb / 2;

                        if (random < threeNoteProb) {
                            numNotes = 3;
                        } else if (random < threeNoteProb + oneAndTwoNoteProb) {
                            numNotes = 2;
                        }
                    }
                }

                const remainingNotes = this.melodyRow.length - this.sequenceIndex;
                numNotes = Math.min(numNotes, remainingNotes);

                const notes = [];
                for (let i = 0; i < numNotes; i++) {
                    notes.push(this.melodyRow[this.sequenceIndex + i]);
                }
                this.sequenceIndex += numNotes;

                const velocityVariation = this.params.velocityVariation / 100;
                const variationRange = velocityVariation * 0.5;
                let adjustedVelocity = this.params.velocity + (Math.random() * variationRange * 2 - variationRange);
                adjustedVelocity = Math.max(0, Math.min(1, adjustedVelocity));
                const adjustedTempo = this.params.tempo + (this.params.tempo * 0.1 * (Math.random() * 2 - 1));

                return {
                    notes: notes,
                    duration: getNoteDuration(this.params.duration),
                    velocity: adjustedVelocity,
                    tempo: adjustedTempo
                };
            }

            generateNoteOptionsHtml(selectedValue) {
                let html = '';
                for (let midi = 21; midi <= 108; midi++) {
                    const noteName = midiToNoteName(midi);
                    html += `<option value="${midi}" ${midi === selectedValue ? 'selected' : ''}>${noteName}</option>`;
                }
                return html;
            }

            getChordProbabilityDescription(value) {
                if (value === 0) return '単音のみ';
                if (value <= 50) return '2音まで';
                return '3音まで';
            }
        }

        let isPlaying = false;
        let intervalId;
        const voices = [new Voice(0)]; // 初期声部を作成

        // 声部の追加ボタンのイベントリスナー
        document.getElementById('addVoice').addEventListener('click', () => {
            const newId = voices.length;
            const newVoice = new Voice(newId);
            voices.push(newVoice);

            // 再生中なら新しい声部の再生も開始
            if (isPlaying) {
                newVoice.startPlaying();
            }

            // WebSocketが接続中なら新しい声部の初期化をサーバーに通知
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'voice_added',
                    voiceId: newId,
                    params: newVoice.params
                }));
            }
        });

        // 再生ボタンを有効化
        document.getElementById('playButton').removeAttribute('disabled');

        // 各音階に対応するピアノサンプルをTone.Bufferで読み込む
        const pianos = {
            "A0": new Tone.Buffer("assets/acoustic_grand_piano-mp3/A0.mp3"),
            "A1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/A1.mp3"),
            "A2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/A2.mp3"),
            "A3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/A3.mp3"),
            "A4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/A4.mp3"),
            "A5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/A5.mp3"),
            "A6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/A6.mp3"),
            "A7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/A7.mp3"),
            "A#0": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Bb0.mp3"),
            "A#1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Bb1.mp3"),
            "A#2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Bb2.mp3"),
            "A#3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Bb3.mp3"),
            "A#4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Bb4.mp3"),
            "A#5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Bb5.mp3"),
            "A#6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Bb6.mp3"),
            "A#7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Bb7.mp3"),
            "B0": new Tone.Buffer("assets/acoustic_grand_piano-mp3/B0.mp3"),
            "B1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/B1.mp3"),
            "B2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/B2.mp3"),
            "B3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/B3.mp3"),
            "B4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/B4.mp3"),
            "B5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/B5.mp3"),
            "B6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/B6.mp3"),
            "B7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/B7.mp3"),
            "C1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/C1.mp3"),
            "C2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/C2.mp3"),
            "C3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/C3.mp3"),
            "C4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/C4.mp3"),
            "C5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/C5.mp3"),
            "C6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/C6.mp3"),
            "C7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/C7.mp3"),
            "C#1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Db1.mp3"),
            "C#2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Db2.mp3"),
            "C#3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Db3.mp3"),
            "C#4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Db4.mp3"),
            "C#5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Db5.mp3"),
            "C#6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Db6.mp3"),
            "C#7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Db7.mp3"),
            "D1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/D1.mp3"),
            "D2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/D2.mp3"),
            "D3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/D3.mp3"),
            "D4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/D4.mp3"),
            "D5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/D5.mp3"),
            "D6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/D6.mp3"),
            "D7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/D7.mp3"),
            "D#1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Eb1.mp3"),
            "D#2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Eb2.mp3"),
            "D#3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Eb3.mp3"),
            "D#4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Eb4.mp3"),
            "D#5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Eb5.mp3"),
            "D#6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Eb6.mp3"),
            "D#7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Eb7.mp3"),
            "E1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/E1.mp3"),
            "E2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/E2.mp3"),
            "E3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/E3.mp3"),
            "E4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/E4.mp3"),
            "E5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/E5.mp3"),
            "E6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/E6.mp3"),
            "E7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/E7.mp3"),
            "F1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/F1.mp3"),
            "F2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/F2.mp3"),
            "F3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/F3.mp3"),
            "F4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/F4.mp3"),
            "F5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/F5.mp3"),
            "F6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/F6.mp3"),
            "F7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/F7.mp3"),
            "F#1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Gb1.mp3"),
            "F#2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Gb2.mp3"),
            "F#3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Gb3.mp3"),
            "F#4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Gb4.mp3"),
            "F#5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Gb5.mp3"),
            "F#6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Gb6.mp3"),
            "F#7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Gb7.mp3"),
            "G1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/G1.mp3"),
            "G2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/G2.mp3"),
            "G3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/G3.mp3"),
            "G4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/G4.mp3"),
            "G5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/G5.mp3"),
            "G6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/G6.mp3"),
            "G7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/G7.mp3"),
            "G#1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Ab1.mp3"),
            "G#2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Ab2.mp3"),
            "G#3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Ab3.mp3"),
            "G#4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Ab4.mp3"),
            "G#5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Ab5.mp3"),
            "G#6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Ab6.mp3"),
            "G#7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Ab7.mp3"),
        };

        // Tone.Samplerにピアノサンプルをセット
        const pianoSampler = new Tone.Sampler(pianos).toDestination();

        // サンプルのロード完了を待つ
        Tone.loaded().then(() => {
            console.log("All samples are loaded");
            document.getElementById('playButton').disabled = false;  // ロード完了後にボタンを有効にする
        });

        // 音楽生成ロジックをクライアントサイドに移動
        function generateNewSequence() {
            const notes = Array.from({length: 12}, (_, i) => i + 60);
            return notes.sort(() => Math.random() - 0.5);
        }

        function retrograde(row) {
            return [...row].reverse();
        }

        function inversion(row) {
            const baseNote = row[0];
            const inverted = row.map(note => baseNote - (note - baseNote));
            return inverted.map(note => ((note - 60 + 12) % 12) + 60);
        }

        let melodyRow = [];
        let baseRow = [];
        let rowRetro = [];
        let rowInverted = [];
        let rowRetroInverted = [];
        let sequenceIndex = 0;
        let octave_shift = 0;
        let isRandomOctave = false;

        function getMelodyRange(value, isUpper) {
            if (value <= 0) return 0;
            
            // 基準となるポイントを定義
            const points = isUpper ? 
                [[0, 0], [25, 12], [50, 24], [75, 36], [100, 48]] :  // 上方向: B4→B5→B6→B7
                [[0, 0], [25, -12], [50, -24], [75, -36], [100, -48]];  // 下方向: C4→C3→C2→C1
            
            // 最も近い2つのポイントを見つける
            let i = 0;
            while (i < points.length - 1 && points[i + 1][0] < value) {
                i++;
            }
            
            // 線形補間
            const x1 = points[i][0];
            const x2 = points[i + 1][0];
            const y1 = points[i][1];
            const y2 = points[i + 1][1];
            
            return Math.round(y1 + (value - x1) * (y2 - y1) / (x2 - x1));
        }

        // オクターブシフトを計算する関数を追加
        function calculateOctaveShift(melodyRange) {
            if (melodyRange === 1) return 0;
            const range = melodyRange - 1;  // 片側の範囲
            return Math.floor(Math.random() * (range * 2 + 1)) - range;
        }

        // 音符の長さを決定する関数
        // complexity: 複雑度 (0-100)
        // 戻り値: 音符の長さを表す文字列 ('2n', '4n', '8n', '16n')
        //
        // 複雑度に応じて以下の確率分布で音符の長さを決定:
        // 中間値は線形補間で確率を計算
        function getNoteDuration(complexity) {
            // 音符の長さの定義（Tone.jsの表記）
            const durations = {
                '2n': '2分音符',
                '4n': '4分音符',
                '8n': '8分音符',
                '16n': '16分音符',
                '32n': '32分音符'
            };

            // 複雑度に応じた確率分布を計算
            let probabilities = {};
            
            if (complexity <= 0) {
                probabilities = { '2n': 1 };
            } else if (complexity <= 25) {
                const ratio = complexity / 25;
                probabilities = {
                    '2n': 1 - (0.5 * ratio),
                    '4n': 0.5 * ratio
                };
            } else if (complexity <= 50) {
                const ratio = (complexity - 25) / 25;
                probabilities = {
                    '2n': 0.5 - (0.167 * ratio),
                    '4n': 0.5 - (0.167 * ratio),
                    '8n': 0.333 * ratio
                };
            } else if (complexity <= 75) {
                const ratio = (complexity - 50) / 25;
                probabilities = {
                    '2n': 0.333 - (0.083 * ratio),
                    '4n': 0.333 - (0.083 * ratio),
                    '8n': 0.333 - (0.083 * ratio),
                    '16n': 0.25 * ratio
                };
            } else {
                const ratio = (complexity - 75) / 25;
                probabilities = {
                    '2n': 0.25 - (0.05 * ratio),
                    '4n': 0.25 - (0.05 * ratio),
                    '8n': 0.25 - (0.05 * ratio),
                    '16n': 0.25 - (0.05 * ratio),
                    '32n': 0.2 * ratio
                };
            }

            // 確率に基づいて音符の長さを選択
            const random = Math.random();
            let accumulator = 0;
            
            for (const [duration, probability] of Object.entries(probabilities)) {
                accumulator += probability;
                if (random <= accumulator) {
                    return duration;
                }
            }
            
            return '2n'; // デフォルトは2分音符
        }

        function getDurationInMilliseconds(duration, tempo) {
            const durationMap = {
                '2n': 2,
                '4n': 1,
                '8n': 0.5,
                '16n': 0.25,
                '32n': 0.125
            };
            
            const beats = durationMap[duration] || 1;
            return (60000 / tempo) * beats;
        }

        function adjustNoteToRange(note, lowerNote, upperNote, coherence, previousNote) {
            // 音符の音高（0-11）を取得
            const pitchClass = note % 12;
            
            // 利用可能なオクターブを計算
            const minOctave = Math.floor(lowerNote / 12);
            const maxOctave = Math.floor(upperNote / 12);
            
            // 可能なオクターブの配列を作成
            const possibleOctaves = [];
            for (let octave = minOctave; octave <= maxOctave; octave++) {
                const noteInOctave = pitchClass + (octave * 12);
                if (noteInOctave >= lowerNote && noteInOctave <= upperNote) {
                    possibleOctaves.push(octave);
                }
            }
            
            // 可能なオクターブがない場合は null を返す（この音はスキップされる）
            if (possibleOctaves.length === 0) return null;
            
            // 前の音がある場合、音程の統一感に基づいて処理
            if (previousNote !== null) {
                const prevOctave = Math.floor(previousNote / 12);
                
                // coherenceが高いほど、前の音近いオクターブを選びやすくする
                const random = Math.random() * 100;
                if (random < coherence) {
                    const nearestOctave = possibleOctaves.reduce((nearest, current) => {
                        return Math.abs(current - prevOctave) < Math.abs(nearest - prevOctave) ? current : nearest;
                    });
                    return pitchClass + (nearestOctave * 12);
                }
            }
            
            const selectedOctave = possibleOctaves[Math.floor(Math.random() * possibleOctaves.length)];
            return pitchClass + (selectedOctave * 12);
        }

        function midiToNoteName(midi) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const note = noteNames[midi % 12];
            const octave = Math.floor(midi / 12) - 1;
            return note + octave;
        }

        function getBaseNote(isUpper) {
            return isUpper ? 71 : 60; // B4: 71, C4: 60
        }

        function getDurationDescription(complexity) {
            if (complexity <= 0) {
                return "2分音符のみ";
            } else if (complexity <= 25) {
                return "2分音符 + 4分音符";
            } else if (complexity <= 50) {
                return "2分音符 + 4分音符 + 8分音符";
            } else if (complexity <= 75) {
                return "2分音符 + 4分音符 + 8分音符 + 16分音符";
            } else {
                return "2分音符 + 4分音符 + 8分音符 + 16分音符 + 32分音符";
            }
        }

        // WebSocket接続の管理
        let ws;
        let clientId = Date.now().toString();

        // WebSocket接続を確立する関数
        function connectWebSocket() {
            const wsUrl = window.location.protocol === 'https:' 
                ? `wss://${window.location.host}/ws/${clientId}`
                : `ws://${window.location.host}/ws/${clientId}`;
            
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected');
                ws.send(JSON.stringify({
                    type: 'init',
                    clientId: clientId
                }));
            };

            // onmessage ハンドラをここに移動
            ws.onmessage = (event) => {
                // console.log('Received message:', event.data);  // デバッグ用ログ追加
                handleWebSocketMessage(event);
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected');
                setTimeout(connectWebSocket, 5000);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        }

        connectWebSocket();

        document.getElementById('playButton').addEventListener('click', async () => {
            if (!isPlaying) {
                await Tone.start();
                isPlaying = true;
                
                function playNextNote() {
                    if (!isPlaying) return;  // 追加: 停止状態なら処理を中断

                    voices.forEach(voice => {                        
                        // 従来の処理
                        if (voice.params.rest) {
                            const restProb = voice.params.restProbability / 100;
                            if (Math.random() < restProb) {
                                return;  // この声部は休符
                            }
                        }
                        const musicData = voice.generateNextNote();
                        musicData.notes.forEach(note => {
                            pianoSampler.triggerAttackRelease(
                                Tone.Frequency(note, "midi").toNote(),
                                musicData.duration,
                                undefined,
                                musicData.velocity
                            );
                        });
                    });

                    // 次の音符のスケジューリング
                    const shortestInterval = Math.min(...voices.map(voice => {
                        const duration = getNoteDuration(voice.params.duration);
                        return getDurationInMilliseconds(duration, voice.params.tempo);
                    }));

                    clearInterval(intervalId);
                    if (isPlaying) {  // 追加: 再生中の場合のみ次の音をスケジュール
                        intervalId = setInterval(playNextNote, shortestInterval);
                    }
                }

                if (ws && ws.readyState === WebSocket.OPEN) {
                    voices.forEach(voice => voice.startPlaying());
                } else {
                    playNextNote();
                }
            }
        });

        // WebSocketメッセージハンドラ
        function handleWebSocketMessage(event) {
            const data = JSON.parse(event.data);
            switch (data.type) {
                case 'init_response':
                    console.log('Initialization complete');
                    break;
                case 'note_data':
                    const voice = voices.find(v => v.id === data.voiceId);
                    if (voice && data.noteData) {
                        voice.noteQueue.push(...data.noteData); // 音情報をキューに追加
                    }
                    break;
                case 'error':
                    console.error('Server error:', data.message);
                    break;
            }
        }

        document.getElementById('stopButton').addEventListener('click', function() {
            isPlaying = false;
            voices.forEach(voice => voice.stopPlaying());
        });

        document.getElementById('velocity').addEventListener('input', function(e) {
            document.getElementById('velocity-value').textContent = e.target.value;
        });

        // 音域選択の初期設定
        const rangeLower = document.getElementById('rangeLower');
        const rangeUpper = document.getElementById('rangeUpper');

        // 音名とMIDI番号のマッピングを生成
        function generateNoteOptions() {
            const notes = [];
            for (let midi = 21; midi <= 108; midi++) {
                const noteName = midiToNoteName(midi);
                notes.push({ midi, noteName });
            }
            return notes;
        }

        // セレクトボックスにオプションを追加
        const notes = generateNoteOptions();
        notes.forEach(note => {
            const lowerOption = new Option(note.noteName, note.midi);
            const upperOption = new Option(note.noteName, note.midi);
            rangeLower.add(lowerOption);
            rangeUpper.add(upperOption);
        });

        // 初期値を設定
        rangeLower.value = "60"; // C4
        rangeUpper.value = "71"; // B4

        function updateRange() {
            const lowerValue = parseInt(rangeLower.value);
            const upperValue = parseInt(rangeUpper.value);
            
            // 値の制限
            if (lowerValue > upperValue) {
                if (this === rangeLower) {
                    rangeLower.value = upperValue;
                } else {
                    rangeUpper.value = lowerValue;
                }
            }
        }

        rangeLower.addEventListener('change', updateRange);
        rangeUpper.addEventListener('change', updateRange);


        document.getElementById('tempo').addEventListener('input', function(e) {
            document.getElementById('tempo-value').textContent = `${e.target.value} BPM`;
        });
        document.getElementById('duration').addEventListener('input', function(e) {
            const value = e.target.value;
            document.getElementById('duration-value').textContent = 
                `${value} (${getDurationDescription(parseInt(value))})`;
        });

        document.getElementById('restProbability').addEventListener('input', function(e) {
            document.getElementById('restProbability-value').textContent = e.target.value + '%';
        });

        // 音程の統一感の初期値を設定（非表示のまま機能させる）
        const melodicCoherence = document.createElement('input');
        melodicCoherence.id = 'melodicCoherence';
        melodicCoherence.type = 'hidden';
        melodicCoherence.value = '0';  // 初期値: 0%
        document.body.appendChild(melodicCoherence);

        document.getElementById('chordProbability').addEventListener('input', function(e) {
            const value = parseInt(e.target.value);
            let description;
            
            if (value === 0) {
                description = "単音のみ";
            } else if (value <= 50) {
                // 2音の確率を計算
                const twoNoteProb = value;
                const oneNoteProb = 100 - twoNoteProb;
                description = `単音(${oneNoteProb}%) + 2音(${twoNoteProb}%)`;
            } else {
                // 3音の確率を計算
                const ratio = (value - 50) / 50; // 0-1の範囲
                const threeNoteProb = Math.round(ratio * 33); // 0-33%
                const remainingProb = 100 - threeNoteProb;
                const oneAndTwoNoteProb = Math.round(remainingProb / 2); // 残りを1音と2音均等に分ける
                
                description = `単音(${oneAndTwoNoteProb}%) + 2音(${oneAndTwoNoteProb}%) + 3音(${threeNoteProb}%)`;
            }
            
            document.getElementById('chordProbability-value').textContent = 
                `${value}% (${description})`;
        });

        document.getElementById('velocityVariation').addEventListener('input', function(e) {
            document.getElementById('velocityVariation-value').textContent = e.target.value + '%';
        });

        // 声部の削除関数
        function removeVoice(targetId) {
            if (voices.length <= 1) return; // 最後の1つは削除不可

            // 指定されたIDの声部を削除
            const index = voices.findIndex(voice => voice.id === targetId);
            if (index !== -1) {
                // 再生中なら該当の声部の再生を停止
                voices[index].stopPlaying();

                // WebSocketが接続中なら声部の削除をサーバーに通知
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'voice_removed',
                        voiceId: targetId
                    }));
                }

                // DOM要素の削除
                const container = document.getElementById(`voice-${targetId}`);
                if (container) {
                    container.remove();
                }

                // 配列から削除
                voices.splice(index, 1);

                // 残りの声部のIDを振り直し
                const remainingContainers = document.querySelectorAll('.voice-controls');
                remainingContainers.forEach((container, newId) => {
                    // 対応する声部を取得
                    const voice = voices[newId];
                    if (voice) {
                        // 声部のIDを更新
                        voice.id = newId;
                        
                        // DOM要素を更新
                        container.id = `voice-${newId}`;
                        container.dataset.voiceId = newId;
                        container.querySelector('h4').textContent = `声部 ${newId + 1}`;
                        container.querySelector('.delete-voice').dataset.voiceId = newId;

                        // WebSocketが接続中なら声部のID更新をサーバーに通知
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'voice_updated',
                                oldId: targetId,
                                newId: newId,
                                params: voice.params
                            }));
                        }
                    }
                });
            }
        }
    </script>
</body>
</html>