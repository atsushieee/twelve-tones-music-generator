<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>リアルタイムピアノ音楽生成</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.39/Tone.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <h1>ピアノ音楽生成アプリ</h1>
    
    <div class="control-group">
        <h3>音量 / 強弱</h3>
        <div class="control-item">
            <label for="velocity">音量:</label>
            <input type="range" id="velocity" min="0" max="1" step="0.1" value="0.5">
            <span id="velocity-value">0.5</span>
        </div>
    </div>

    <div class="control-group">
        <h3>音域 / 動きの量</h3>
        <div class="control-item">
            <label>下限音:</label>
            <select id="rangeLower">
                <!-- オプションはJavaScriptで動的に生成 -->
            </select>
            <label style="margin-left: 20px;">上限音:</label>
            <select id="rangeUpper">
                <!-- オプションはJavaScriptで動的に生成 -->
            </select>
        </div>
    </div>

    <div class="control-group">
        <h3>テンポ と音符 / 休符 の長さ</h3>        
        <div class="control-item">
            <label for="tempo">テンポ:</label>
            <input type="range" id="tempo" min="60" max="480" step="10" value="240">
            <span id="tempo-value">240 BPM</span>
        </div>
        
        <div class="control-item">
            <label for="duration">複雑度:</label>
            <input type="range" id="duration" min="0" max="100" step="5" value="50">
            <span id="duration-value">50 (2分音符 + 4分音符 + 8分音符)</span>
        </div>
        
        <div class="control-item">
            <label for="rest">休符を含める:</label>
            <input type="checkbox" id="rest" checked>
        </div>
        
        <div class="control-item">
            <label for="restProbability">休符の確率:</label>
            <input type="range" id="restProbability" min="10" max="50" step="5" value="25">
            <span id="restProbability-value">25%</span>
        </div>
    </div>

    <div class="control-group">
        <h3>同時発音数</h3>
        <div class="control-item">
            <label for="chordProbability">同時発音の確率:</label>
            <input type="range" id="chordProbability" min="0" max="100" step="5" value="0">
            <span id="chordProbability-value">0% (単音のみ)</span>
        </div>
    </div>

    <button id="playButton" disabled>音楽を再生</button>
    <button id="stopButton">停止</button>

    <script>
        let isPlaying = false;
        let intervalId; // インターバルIDを保持する変数

        // 各音階に対応するピアノサンプルをTone.Bufferで読み込む
        const pianos = {
            "A0": new Tone.Buffer("assets/acoustic_grand_piano-mp3/A0.mp3"),
            "A1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/A1.mp3"),
            "A2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/A2.mp3"),
            "A3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/A3.mp3"),
            "A4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/A4.mp3"),
            "A5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/A5.mp3"),
            "A6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/A6.mp3"),
            "A7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/A7.mp3"),
            "A#0": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Bb0.mp3"),
            "A#1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Bb1.mp3"),
            "A#2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Bb2.mp3"),
            "A#3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Bb3.mp3"),
            "A#4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Bb4.mp3"),
            "A#5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Bb5.mp3"),
            "A#6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Bb6.mp3"),
            "A#7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Bb7.mp3"),
            "B0": new Tone.Buffer("assets/acoustic_grand_piano-mp3/B0.mp3"),
            "B1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/B1.mp3"),
            "B2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/B2.mp3"),
            "B3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/B3.mp3"),
            "B4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/B4.mp3"),
            "B5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/B5.mp3"),
            "B6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/B6.mp3"),
            "B7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/B7.mp3"),
            "C1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/C1.mp3"),
            "C2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/C2.mp3"),
            "C3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/C3.mp3"),
            "C4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/C4.mp3"),
            "C5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/C5.mp3"),
            "C6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/C6.mp3"),
            "C7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/C7.mp3"),
            "C#1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Db1.mp3"),
            "C#2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Db2.mp3"),
            "C#3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Db3.mp3"),
            "C#4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Db4.mp3"),
            "C#5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Db5.mp3"),
            "C#6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Db6.mp3"),
            "C#7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Db7.mp3"),
            "D1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/D1.mp3"),
            "D2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/D2.mp3"),
            "D3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/D3.mp3"),
            "D4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/D4.mp3"),
            "D5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/D5.mp3"),
            "D6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/D6.mp3"),
            "D7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/D7.mp3"),
            "D#1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Eb1.mp3"),
            "D#2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Eb2.mp3"),
            "D#3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Eb3.mp3"),
            "D#4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Eb4.mp3"),
            "D#5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Eb5.mp3"),
            "D#6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Eb6.mp3"),
            "D#7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Eb7.mp3"),
            "E1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/E1.mp3"),
            "E2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/E2.mp3"),
            "E3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/E3.mp3"),
            "E4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/E4.mp3"),
            "E5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/E5.mp3"),
            "E6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/E6.mp3"),
            "E7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/E7.mp3"),
            "F1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/F1.mp3"),
            "F2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/F2.mp3"),
            "F3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/F3.mp3"),
            "F4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/F4.mp3"),
            "F5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/F5.mp3"),
            "F6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/F6.mp3"),
            "F7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/F7.mp3"),
            "F#1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Gb1.mp3"),
            "F#2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Gb2.mp3"),
            "F#3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Gb3.mp3"),
            "F#4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Gb4.mp3"),
            "F#5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Gb5.mp3"),
            "F#6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Gb6.mp3"),
            "F#7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Gb7.mp3"),
            "G1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/G1.mp3"),
            "G2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/G2.mp3"),
            "G3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/G3.mp3"),
            "G4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/G4.mp3"),
            "G5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/G5.mp3"),
            "G6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/G6.mp3"),
            "G7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/G7.mp3"),
            "G#1": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Ab1.mp3"),
            "G#2": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Ab2.mp3"),
            "G#3": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Ab3.mp3"),
            "G#4": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Ab4.mp3"),
            "G#5": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Ab5.mp3"),
            "G#6": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Ab6.mp3"),
            "G#7": new Tone.Buffer("assets/acoustic_grand_piano-mp3/Ab7.mp3"),
        };

        // Tone.Samplerにピアノサンプルをセット
        const pianoSampler = new Tone.Sampler(pianos).toDestination();

        // サンプルのロード完了を待つ
        Tone.loaded().then(() => {
            console.log("All samples are loaded");
            document.getElementById('playButton').disabled = false;  // ロード完了後にボタンを有効にする
        });

        // 音楽生成ロジックをクライアントサイドに移動
        function generateNewSequence() {
            const notes = Array.from({length: 12}, (_, i) => i + 60);
            return notes.sort(() => Math.random() - 0.5);
        }

        function retrograde(row) {
            return [...row].reverse();
        }

        function inversion(row) {
            const baseNote = row[0];
            const inverted = row.map(note => baseNote - (note - baseNote));
            return inverted.map(note => ((note - 60 + 12) % 12) + 60);
        }

        let melodyRow = [];
        let baseRow = [];
        let rowRetro = [];
        let rowInverted = [];
        let rowRetroInverted = [];
        let sequenceIndex = 0;
        let octave_shift = 0;
        let isRandomOctave = false;

        function getMelodyRange(value, isUpper) {
            if (value <= 0) return 0;
            
            // 基準となるポイントを定義
            const points = isUpper ? 
                [[0, 0], [25, 12], [50, 24], [75, 36], [100, 48]] :  // 上方向: B4→B5→B6→B7
                [[0, 0], [25, -12], [50, -24], [75, -36], [100, -48]];  // 下方向: C4→C3→C2→C1
            
            // 最も近い2つのポイントを見つける
            let i = 0;
            while (i < points.length - 1 && points[i + 1][0] < value) {
                i++;
            }
            
            // 線形補間
            const x1 = points[i][0];
            const x2 = points[i + 1][0];
            const y1 = points[i][1];
            const y2 = points[i + 1][1];
            
            return Math.round(y1 + (value - x1) * (y2 - y1) / (x2 - x1));
        }

        // オクターブシフトを計算する関数を追加
        function calculateOctaveShift(melodyRange) {
            if (melodyRange === 1) return 0;
            const range = melodyRange - 1;  // 片側の範囲
            return Math.floor(Math.random() * (range * 2 + 1)) - range;
        }

        // 音符の長さを決定する関数
        // complexity: 複雑度 (0-100)
        // 戻り値: 音符の長さを表す文字列 ('2n', '4n', '8n', '16n')
        //
        // 複雑度に応じて以下の確率分布で音符の長さを決定:
        // 中間値は線形補間で確率を計算
        function getNoteDuration(complexity) {
            // 音符の長さの定義（Tone.jsの表記）
            const durations = {
                '2n': '2分音符',
                '4n': '4分音符',
                '8n': '8分音符',
                '16n': '16分音符',
                '32n': '32分音符'
            };

            // 複雑度に応じた確率分布を計算
            let probabilities = {};
            
            if (complexity <= 0) {
                probabilities = { '2n': 1 };
            } else if (complexity <= 25) {
                const ratio = complexity / 25;
                probabilities = {
                    '2n': 1 - (0.5 * ratio),
                    '4n': 0.5 * ratio
                };
            } else if (complexity <= 50) {
                const ratio = (complexity - 25) / 25;
                probabilities = {
                    '2n': 0.5 - (0.167 * ratio),
                    '4n': 0.5 - (0.167 * ratio),
                    '8n': 0.333 * ratio
                };
            } else if (complexity <= 75) {
                const ratio = (complexity - 50) / 25;
                probabilities = {
                    '2n': 0.333 - (0.083 * ratio),
                    '4n': 0.333 - (0.083 * ratio),
                    '8n': 0.333 - (0.083 * ratio),
                    '16n': 0.25 * ratio
                };
            } else {
                const ratio = (complexity - 75) / 25;
                probabilities = {
                    '2n': 0.25 - (0.05 * ratio),
                    '4n': 0.25 - (0.05 * ratio),
                    '8n': 0.25 - (0.05 * ratio),
                    '16n': 0.25 - (0.05 * ratio),
                    '32n': 0.2 * ratio
                };
            }

            // 確率に基づいて音符の長さを選択
            const random = Math.random();
            let accumulator = 0;
            
            for (const [duration, probability] of Object.entries(probabilities)) {
                accumulator += probability;
                if (random <= accumulator) {
                    return duration;
                }
            }
            
            return '2n'; // デフォルトは2分音符
        }

        function getDurationInMilliseconds(duration, tempo) {
            const durationMap = {
                '2n': 2,
                '4n': 1,
                '8n': 0.5,
                '16n': 0.25,
                '32n': 0.125
            };
            
            const beats = durationMap[duration] || 1;
            return (60000 / tempo) * beats;
        }

        function adjustNoteToRange(note, lowerNote, upperNote, coherence, previousNote) {
            // 音符の音高（0-11）を取得
            const pitchClass = note % 12;
            
            // 利用可能なオクターブを計算
            const minOctave = Math.floor(lowerNote / 12);
            const maxOctave = Math.floor(upperNote / 12);
            
            // 可能なオクターブの配列を作成
            const possibleOctaves = [];
            for (let octave = minOctave; octave <= maxOctave; octave++) {
                const noteInOctave = pitchClass + (octave * 12);
                if (noteInOctave >= lowerNote && noteInOctave <= upperNote) {
                    possibleOctaves.push(octave);
                }
            }
            
            // 可能なオクターブがない場合は null を返す（この音はスキップされる）
            if (possibleOctaves.length === 0) return null;
            
            // 前の音がある場合、音程の統一感に基づいて処理
            if (previousNote !== null) {
                const prevOctave = Math.floor(previousNote / 12);
                
                // coherenceが高いほど、前の音近いオクターブを選びやすくする
                const random = Math.random() * 100;
                if (random < coherence) {
                    const nearestOctave = possibleOctaves.reduce((nearest, current) => {
                        return Math.abs(current - prevOctave) < Math.abs(nearest - prevOctave) ? current : nearest;
                    });
                    return pitchClass + (nearestOctave * 12);
                }
            }
            
            const selectedOctave = possibleOctaves[Math.floor(Math.random() * possibleOctaves.length)];
            return pitchClass + (selectedOctave * 12);
        }

        function generateNextNote(velocity, tempo) {
            if (!melodyRow.length || sequenceIndex >= melodyRow.length) {
                const lastNote = melodyRow.length ? melodyRow[melodyRow.length - 1] : null;
                
                if (!melodyRow.length || Math.random() < 0.25) {
                    baseRow = generateNewSequence();
                    // 各変形を生成
                    rowRetro = retrograde(baseRow);
                    rowInverted = inversion(baseRow);
                    rowRetroInverted = retrograde(rowInverted);
                }
                
                // 基本形、逆行形、転回形、逆行転回形からランダムに選択
                const selectedRow = [baseRow, rowRetro, rowInverted, rowRetroInverted][Math.floor(Math.random() * 4)];
                
                // 選択された音列に対して音域調整を行う
                const coherence = parseInt(document.getElementById('melodicCoherence').value);
                const lowerNote = parseInt(document.getElementById('rangeLower').value);
                const upperNote = parseInt(document.getElementById('rangeUpper').value);
                
                // 音域調整された音列を melodyRow に設定（前の12音列の最後の音を考慮）
                melodyRow = selectedRow.map((note, index) => {
                    const previousNote = index > 0 ? melodyRow[index - 1] : lastNote;
                    return adjustNoteToRange(note, lowerNote, upperNote, coherence, previousNote);
                }).filter(note => note !== null); // null の音（範囲外）を除外
                
                sequenceIndex = 0;
            }

            const chordProb = parseInt(document.getElementById('chordProbability').value);
            let numNotes = 1;
            
            if (chordProb > 0) {
                const random = Math.random() * 100;
                if (chordProb <= 50) {
                    // 0-50%の範囲では1音か2音
                    // 2音の確率を線形補間: 0% -> 50%
                    const twoNoteProb = chordProb; // 0-50の値がそのまま2音を鳴らす確率になる
                    if (random < twoNoteProb) numNotes = 2;
                } else {
                    // 50-100%の範囲では1音、2音、3音
                    // 3音の確率を線形補間: 0% -> 33%
                    // 2音と1音の確率は均等に減少: 50% -> 33%
                    const ratio = (chordProb - 50) / 50; // 0-1の範囲
                    const threeNoteProb = ratio * 33; // 0-33%
                    const remainingProb = 100 - threeNoteProb;
                    const oneAndTwoNoteProb = remainingProb / 2; // 残りを1音と2音で均等に分ける

                    if (random < threeNoteProb) {
                        numNotes = 3;
                    } else if (random < threeNoteProb + oneAndTwoNoteProb) {
                        numNotes = 2;
                    }
                    // else: numNotes = 1 (デフォルト値のまま)
                }
            }

            // 残りの音数を確認
            const remainingNotes = melodyRow.length - sequenceIndex;
            numNotes = Math.min(numNotes, remainingNotes);

            // 複数の音を取得
            const notes = [];
            for (let i = 0; i < numNotes; i++) {
                notes.push(melodyRow[sequenceIndex + i]);
            }
            sequenceIndex += numNotes;

            // velocityとtempoの調整（既存のコード）
            const adjustedVelocity = velocity + (Math.random() * 0.2 - 0.1);
            const adjustedTempo = tempo + (tempo * 0.1 * (Math.random() * 2 - 1));
            const complexity = parseInt(document.getElementById('duration').value);

            return {
                notes: notes,
                duration: getNoteDuration(complexity),
                velocity: adjustedVelocity,
                tempo: adjustedTempo
            };
        }

        function midiToNoteName(midi) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const note = noteNames[midi % 12];
            const octave = Math.floor(midi / 12) - 1;
            return note + octave;
        }

        function getBaseNote(isUpper) {
            return isUpper ? 71 : 60; // B4: 71, C4: 60
        }

        function getDurationDescription(complexity) {
            if (complexity <= 0) {
                return "2分音符のみ";
            } else if (complexity <= 25) {
                return "2分音符 + 4分音符";
            } else if (complexity <= 50) {
                return "2分音符 + 4分音符 + 8分音符";
            } else if (complexity <= 75) {
                return "2分音符 + 4分音符 + 8分音符 + 16分音符";
            } else {
                return "2分音符 + 4分音符 + 8分音符 + 16分音符 + 32分音符";
            }
        }

        document.getElementById('playButton').addEventListener('click', async () => {
            if (!isPlaying) {
                await Tone.start();
                isPlaying = true;
                
                function playNextNote() {
                    const velocity = parseFloat(document.getElementById('velocity').value);
                    const tempo = parseInt(document.getElementById('tempo').value);
                    const includeRest = document.getElementById('rest').checked;
                    
                    // 休符を含める設定がオンの場合、設定された確率で休符を挿入
                    if (includeRest) {
                        const restProb = parseInt(document.getElementById('restProbability').value) / 100;
                        if (Math.random() < restProb) {
                            const complexity = parseInt(document.getElementById('duration').value);
                            const restDuration = getNoteDuration(complexity);
                            const interval = getDurationInMilliseconds(restDuration, tempo);
                            
                            clearInterval(intervalId);
                            intervalId = setInterval(playNextNote, interval);
                            return;
                        }
                    }
                    
                    const musicData = generateNextNote(velocity, tempo);
                    
                    musicData.notes.forEach(note => {
                        pianoSampler.triggerAttackRelease(
                            Tone.Frequency(note, "midi").toNote(),
                            musicData.duration,
                            undefined,
                            musicData.velocity
                        );
                    });
                    
                    Tone.Transport.bpm.value = musicData.tempo;

                    clearInterval(intervalId);
                    const interval = getDurationInMilliseconds(musicData.duration, musicData.tempo);
                    intervalId = setInterval(playNextNote, interval);
                }

                playNextNote();
            }
        });

        document.getElementById('stopButton').addEventListener('click', () => {
            if (isPlaying) {
                clearInterval(intervalId);
                isPlaying = false;
            }
        });

        document.getElementById('velocity').addEventListener('input', function(e) {
            document.getElementById('velocity-value').textContent = e.target.value;
        });

        // 音域選択の初期設定
        const rangeLower = document.getElementById('rangeLower');
        const rangeUpper = document.getElementById('rangeUpper');

        // 音名とMIDI番号のマッピングを生成
        function generateNoteOptions() {
            const notes = [];
            for (let midi = 21; midi <= 108; midi++) {
                const noteName = midiToNoteName(midi);
                notes.push({ midi, noteName });
            }
            return notes;
        }

        // セレクトボックスにオプションを追加
        const notes = generateNoteOptions();
        notes.forEach(note => {
            const lowerOption = new Option(note.noteName, note.midi);
            const upperOption = new Option(note.noteName, note.midi);
            rangeLower.add(lowerOption);
            rangeUpper.add(upperOption);
        });

        // 初期値を設定
        rangeLower.value = "60"; // C4
        rangeUpper.value = "71"; // B4

        function updateRange() {
            const lowerValue = parseInt(rangeLower.value);
            const upperValue = parseInt(rangeUpper.value);
            
            // 値の制限
            if (lowerValue > upperValue) {
                if (this === rangeLower) {
                    rangeLower.value = upperValue;
                } else {
                    rangeUpper.value = lowerValue;
                }
            }
        }

        rangeLower.addEventListener('change', updateRange);
        rangeUpper.addEventListener('change', updateRange);


        document.getElementById('tempo').addEventListener('input', function(e) {
            document.getElementById('tempo-value').textContent = `${e.target.value} BPM`;
        });
        document.getElementById('duration').addEventListener('input', function(e) {
            const value = e.target.value;
            document.getElementById('duration-value').textContent = 
                `${value} (${getDurationDescription(parseInt(value))})`;
        });

        document.getElementById('restProbability').addEventListener('input', function(e) {
            document.getElementById('restProbability-value').textContent = e.target.value + '%';
        });

        // 音程の統一感の初期値を設定（非表示のまま機能させる）
        const melodicCoherence = document.createElement('input');
        melodicCoherence.id = 'melodicCoherence';
        melodicCoherence.type = 'hidden';
        melodicCoherence.value = '0';  // 初期値: 0%
        document.body.appendChild(melodicCoherence);

        document.getElementById('chordProbability').addEventListener('input', function(e) {
            const value = parseInt(e.target.value);
            let description;
            
            if (value === 0) {
                description = "単音のみ";
            } else if (value <= 50) {
                // 2音の確率を計算
                const twoNoteProb = value;
                const oneNoteProb = 100 - twoNoteProb;
                description = `単音(${oneNoteProb}%) + 2音(${twoNoteProb}%)`;
            } else {
                // 3音の確率を計算
                const ratio = (value - 50) / 50; // 0-1の範囲
                const threeNoteProb = Math.round(ratio * 33); // 0-33%
                const remainingProb = 100 - threeNoteProb;
                const oneAndTwoNoteProb = Math.round(remainingProb / 2); // 残りを1音と2音で均等に分ける
                
                description = `単音(${oneAndTwoNoteProb}%) + 2音(${oneAndTwoNoteProb}%) + 3音(${threeNoteProb}%)`;
            }
            
            document.getElementById('chordProbability-value').textContent = 
                `${value}% (${description})`;
        });
    </script>
</body>
</html>
